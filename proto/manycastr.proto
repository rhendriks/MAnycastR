syntax = "proto3";
package manycastr;

// The controller which controls and is responsible for most communication
service Controller {
  // Worker lets the Orc know the measurement is finished
  rpc MeasurementFinished(Finished) returns (Ack) {}
  // Worker connects with the Orc, which returns a stream for future instructions
  rpc WorkerConnect(Worker) returns (stream Instruction) {}
  // CLI instructs Orc to perform a measurement and establishes a stream for the Orc to send back replies
  rpc DoMeasurement(ScheduleMeasurement) returns (stream ReplyBatch) {}
  // CLI instructs Orc to perform a live measurement and establishes a stream for the Orc to send back replies
  rpc LiveMeasurement(stream LiveMeasurementMessage) returns (stream ReplyBatch) {}
  // CLI asks Orc its current status (list of connected workers and measurements)
  rpc ListWorkers(Empty) returns (Status) {}
  // Worker sends measurement replies to the Orc
  rpc SendResult(ReplyBatch) returns (Ack) {}
}

// Metadata for the measurement session (sent once at the start)
message LiveMeasurementMetadata {
  string url = 1; // URL to encode in probes
}

// Per-task information (streamed for each task)
message LiveTask {
  uint32 worker_id = 1;       // Worker from which to send the probe (0 for any worker)
  Origin origin = 2;           // Origin to send the probe from
  Address dst = 3;             // Destination to send the probe to
  uint32 m_type = 4;           // Measurement type (ICMP, UDP, TCP, DNS)
  bool is_ipv6 = 5;            // Whether to use IPv6
  optional string record = 6;  // Record to use for DNS queries (TXT/A/AAAA)
  bool is_latency = 7;         // Whether the measurement is for latency
}

// Wrapper message for streaming tasks or sending metadata
message LiveMeasurementMessage {
  oneof msg {
    LiveMeasurementMetadata metadata = 1; // Sent once
    LiveTask task = 2;                    // Sent multiple times
  }
}

// Empty message
message Empty {}

// Acknowledgement of a measurement with a boolean whether it was successful or not and a possible error message.
message Ack {
  bool is_success = 1;
  string error_message = 2;
}

// Finished message, sent by a worker to the orchestrator when a measurement is finished, or as acknowledgement of a received task result
message Finished {
  uint32 m_id = 1;
  uint32 worker_id = 2;
}

enum MeasurementType {
  LACES = 0;
  VERFPLOETER = 1;
  ANYCAST_LATENCY = 2;
  UNICAST_LATENCY = 3;
  ANYCAST_TRACEROUTE = 4;
}

enum ProtocolType {
  ICMP = 0;
  A_DNS = 1;
  TCP = 2;
  CHAOS_DNS = 3;
}

// Schedule a measurement with the orchestrator
message ScheduleMeasurement {
  uint32 probing_rate = 1; // Probing rate (probes per second)
  repeated Configuration configurations = 2; // Configuration of worker and origin combinations
  ProtocolType p_type = 3; // Measurement type (ICMP, UDP, TCP, DNS)
  uint32 worker_interval = 4; // interval between probes from different workers
  MeasurementType m_type = 5;
  repeated Address hitlist = 6; // target addresses to probe
  optional string record = 7; // Record to send CHAOS (TXT) or A/AAAA requests for
  optional string url = 8; // URL to encode in probes (e.g., opt-out link)
  uint32 probe_interval = 9; // interval between probes from/to the same origin,dst pair
  uint32 number_of_probes = 10; // number of probes to send per origin,dst pair
  bool is_ipv6 = 11; // whether the measurement is for IPv6
  bool is_record = 12; // whether to send IPv4 probes with the Record Route options
  optional TraceOptions trace_options = 13; // Optional traceroute options
  bool is_responsive = 14; // Whether to probe a target once for responsiveness before sending measurement probes
}

// A list of workers
message Status {
  repeated Worker workers = 1;
}

// Worker definition, contains a worker ID, metadata (hostname), status
message Worker {
  fixed32 worker_id = 1;
  string hostname = 2;
  string status = 3; // IDLE, PROBING, LISTENING, DISCONNECTED
  Address unicast_v6 = 4;
  Address unicast_v4 = 5;
}

// Address message, can be either an IPv4 or IPv6 address
message Address {
  oneof value {
    fixed32 v4 = 1;
    IPv6 v6 = 2;
    Empty unicast = 3; // use unicast origin
  }
}

// IPv6 address message (protobuf does not support 128 bit values)
message IPv6 {
  fixed64 high = 1; // most significant 64 bits
  fixed64 low = 2; // least significant 64 bits
}


// A task for a worker, either a start or end message, a list of targets, or a traceroute task
message Instruction {
  oneof instruction_type {
    End end = 1; // End measurement [control]
    Start start = 2; // Start measurement [control]
    Init init = 3; // Initial message to worker (contains worker ID) [control]
    Tasks tasks = 4; // List of tasks (probes/traceroutes) to perform [measurement]
  }
}

// A list of tasks (i.e., measurements) for a worker to perform
message Tasks {
  repeated Task tasks = 1;
}

// A task (i.e., measurement) for a worker to perform, either a probe, traceroute, or discovery task
message Task {
  oneof task_type {
    Probe probe = 1; // A probe task (e.g., regular ping)
    Trace trace = 2; // A traceroute task (to a specific TTL)
    Probe discovery = 3; // A discovery task (e.g., to check for responsiveness or catching PoP)
  }
}

// Initial message to worker, contains the worker ID assigned by the orchestrator
message Init {
  uint32 worker_id = 1;
}

// A start control instruction, forwards the configuration to the worker
message Start {
  uint32 rate = 1;
  uint32 m_id = 2;
  ProtocolType p_type = 3; // Measurement type (ICMP, UDP, TCP, DNS)
  repeated Origin tx_origins = 4; // origins to send with
  repeated Origin rx_origins = 5; // origins to listen for
  optional string record = 6; // domain to use for DNS queries (TXT/A/AAAA)
  optional string url = 7; // URL encoded in probes
  bool is_ipv6 = 8; // whether the measurement is for IPv6
  bool is_record = 9; // send IPv4 probes with the Record Route option
  MeasurementType m_type = 10; // Measurement type
}

message TraceOptions {
  uint32 max_failures = 1; // Maximum number of consecutive timeouts before terminating the traceroute
  uint32 max_hops = 2; // Maximum number of hops to discover (to avoid routing loops)
  uint32 timeout = 3; // Maximum time to wait for trace replies before triggering timeout (in seconds)
  uint32 initial_hop = 4; // Initial TTL value for traceroute measurements
}

// An end message, indicates the worker should stop sending out probes
message End {
  uint32 code = 1; // 0 -> finished, 1 -> CLI disconnect
}

// Origin: the source address and port combinations used by workers in a measurement, alongside an identifier
message Origin {
  Address src = 1;
  fixed32 sport = 2;
  fixed32 dport = 3;
  fixed32 origin_id = 4;
}

// Configuration: mapping of worker ID to origin
message Configuration {
  Origin origin = 1;
  uint32 worker_id = 2;
}

// A probing task, containing the target address to probe
message Probe {
  Address dst = 1; // target address of the probe
}

// A traceroute task, containing a destination addres, the TTL value to use, the protocol type, and the origin to use
message Trace {
  Address dst = 1; // target address of the traceroute probe
  uint32 ttl = 2; // TTL to use for the traceroute probe
  uint32 origin_id = 3; // Origin to send the traceroute probe from [None if a single origin is used]
}

// A ReplyBatch, contains the worker that received the measurement replies, and the replies themselves
message ReplyBatch {
  uint32 rx_id = 1;
  repeated Reply results = 2; // forwarded to CLI by the Orchestrator
}

message Reply {
  oneof reply_data {
    MeasurementReply measurement = 1; // result
    DiscoveryReply discovery = 2; // follow-up
    TraceReply trace = 3; // result + follow-up
  }
}

// Contains discovery reply data (used for follow-up tasks)
message DiscoveryReply {
  Address src = 1;
  fixed32 origin_id = 2; // ID of the destination origin (ip, ports) of the reply
}

// Contains measured reply data (forwarded to the CLI and written to file)
message MeasurementReply {
  Address src = 1;
  fixed32 ttl = 2;
  fixed32 origin_id = 3; // ID of the destination origin (ip, ports) of the reply
  uint64 rx_time = 4;
  uint64 tx_time = 5;
  fixed32 tx_id = 6;
  optional string chaos = 7;
  optional RecordedHops recorded_hops = 8;
}

// Traceroute reply
message TraceReply {
  Address hop_addr = 1;
  fixed32 ttl = 2;
  fixed32 origin_id = 3; // ID of the destination origin (ip, ports) of the reply
  uint64 rx_time = 4; // 32 bit microseconds time
  uint64 tx_time = 5; // 16 bit microseconds time
  fixed32 tx_id = 6;
  Address trace_dst = 7;
  uint32 hop_count = 8; // TTL used to trigger this reply
}

// Record Route hops found
message RecordedHops {
  repeated Address hops = 1;
}