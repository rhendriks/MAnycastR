// This file is used in combination with rust protobuf https://docs.rs/protobuf/latest/protobuf/
// From this, code is generated which can be found in src/schema
// It generated verfploeter.rs and verfploeter_grpc.rs

// https://blog.logrocket.com/rust-and-grpc-a-complete-guide/

// This file details the protocol buffers, which contain the data exchanged between the server/clients.
// I.e. this is the protocol buffer file

// version of protocol buffer used
syntax = "proto3";

package verfploeter;

// The controller which controls and is responsible for most communication
service Controller {
  // Client lets the server know the task is finished
  rpc TaskFinished(TaskId) returns (Ack) {}
  // Client announces itself, and starts connection with the Server. The server sends a stream of Task
  rpc ClientConnect(Metadata) returns (stream Task) {}
  // CLI instructs Server to perform a task
  rpc DoTask(ScheduleTask) returns (stream TaskResult) {}
  // CLI asks Server to list clients, Server returns ClientList
  rpc ListClients(Empty) returns (ClientList) {}
  // Client sends TaskResult to Server
  rpc SendResult(TaskResult) returns (Ack) {}
  // Client obtains a unique client ID from the server
  rpc GetClientId(Metadata) returns (ClientId) {}
}

// Empty message
message Empty {}

// Acknowledgement of a task, with a task ID, a boolean whether it was successful or not, and a possible error message.
message Ack {
  bool success = 1;
  string error_message = 2;
}

// Send a task ID
message TaskId { uint32 task_id = 1; }

message ClientId {uint32 client_id = 1;}

// Schedule a task, with a Client who has to execute it (defined below), and a Ping (defined below)
message ScheduleTask {
  oneof data {
    Ping ping = 2;
    UDP udp = 3;
    TCP tcp = 4;
  }
}

// A list of Client (note the 'repeated' keyword)
message ClientList {
  repeated Client clients = 1;
}

// A client, which contains an index, and metadata (defined below)
message Client {
  fixed32 client_id = 1;
  Metadata metadata = 2;
}

// A task, with a task ID, can be either a Ping or Empty task
message Task {
  uint32 task_id = 1;
  oneof data {
    Ping ping = 2;
    UDP udp = 3;
    TCP tcp = 4;
    Empty empty = 5;
  }
}

// Metadata (as used in Client), contains a hostname and a version.
message Metadata {
  string hostname = 1;
}

// A Ping (used in Task), which has a single source address and a list of destination addresses.
message Ping {
  fixed32 source_address = 1;
  repeated fixed32 destination_addresses = 2;
}

message UDP {
  fixed32 source_address = 1;
  repeated fixed32 destination_addresses = 2;
}

message TCP {
  fixed32 source_address = 1;
  repeated fixed32 destination_addresses = 2;
}

// A TaskResult (i.e. the result of a Ping), contains the task ID, Client that executed the task,
// a list of Result (one for each targeted dest. address), a boolean indicating whether it was finished.
message TaskResult {
  uint32 task_id = 1;
  Client client = 2;
  repeated VerfploeterResult result_list = 3;
}

// A result, always contains a PingResult
message VerfploeterResult {
  oneof value {
    PingResult ping = 1;
    UDPResult udp = 2;
    TCPResult tcp = 3;
  }
}

message IPv4Result {
  fixed32 source_address = 1;
  fixed32 destination_address = 2;
  fixed32 ttl = 3;
}

// Result of Ping. It is the result of a single ping (i.e. a received ICMP response)
// Contains the source and destination of the ping, the receive time, the payload, and the ttl.
message PingResult {
  uint64 receive_time = 1;
  IPv4Result ipv4_result = 2;
  PingPayload payload = 3;
}

// PingPayload. The payload of a ping, with task ID, transmission time, source/dest address.
message PingPayload {
  uint64 transmit_time = 1;
  fixed32 source_address = 2;
  fixed32 destination_address = 3;
  fixed32 sender_client_id = 4;
}

message UDPResult {
  uint64 receive_time = 1;
  fixed32 source_port = 2;
  fixed32 destination_port = 3;
  IPv4Result ipv4_result = 4;
  UDPPayload payload = 5;
}

message UDPPayload {
  uint64 transmit_time = 1;
  fixed32 source_address = 2;
  fixed32 destination_address = 3;
  fixed32 sender_client_id = 4;
  fixed32 source_port = 5;
  // TODO append with resolver used and other DNS information that's interesting
}

message TCPResult {
  uint64 receive_time = 1;
  IPv4Result ipv4_result = 2;
  fixed32 source_port = 3;
  fixed32 destination_port = 4;
  fixed32 seq = 5;
  fixed32 ack = 6;
}